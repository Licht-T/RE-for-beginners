\subsubsection{MSVC}

MSVC 2010でコンパイルしてみる。

\begin{lstlisting}
cl 1.cpp /Fa1.asm
\end{lstlisting}

(\TT{/Fa} オプションは、アセンブリリストファイルを生成するようにコンパイラに指示する)

\begin{lstlisting}[caption=MSVC 2010,style=customasmx86]
CONST	SEGMENT
$SG3830	DB	'hello, world', 0AH, 00H
CONST	ENDS
PUBLIC	_main
EXTRN	_printf:PROC
; Function compile flags: /Odtp
_TEXT	SEGMENT
_main	PROC
	push	ebp
	mov	ebp, esp
	push	OFFSET $SG3830
	call	_printf
	add	esp, 4
	xor	eax, eax
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
\end{lstlisting}

MSVCは、Intel構文でアセンブリリストを生成します。 Intel構文とAT\&T構文の違いについては、\myref{ATT_syntax}において説明している。

コンパイラは、\TT{1.exe}にリンクされる\TT{1.obj}というファイルを生成する。
このファイルには\TT{CONST}（データ定数用）と\TT{\_TEXT}（コード用）の2つのセグメントが含まれている。

\myindex{\CLanguageElements!const}
\label{string_is_const_char}
C/C++の文字列\TT{hello, world}は、\TT{const char[]}\InSqBrackets{\TCPPPL p176, 7.3.2}型を持つが、文字列そのものに独自の名前はありません。
コンパイラは何らかの形で文字列を処理する必要があるため、文字列に対して内部名\TT{\$SG3830}を定義している。

そのため、この例は次のように書き換えることもできる。

\lstinputlisting[style=customc]{patterns/01_helloworld/hw_2.c}

アセンブリリストに戻って確認すると、文字列は \CCpp 文字列の標準であるNULL文字で終端されている。 \CCpp 文字列の詳細は： \myref{C_strings} を参照のこと．

\TT{\_TEXT}というコードセグメントには、 \main{} という1つの関数だけが存在する。\main 関数は、プロローグコードで始まり、エピローグコードで終了する（これは，\main 関数以外のほぼすべての関数に当てはまる）．
\footnote{詳細は『関数のプロローグとエピローグ』についてのセクションを参照 ~(\myref{sec:prologepilog})}

\myindex{x86!\Instructions!CALL}
関数のプロローグの後、\printf{} 関数が呼び出される。
\INS{CALL \_printf}.
\myindex{x86!\Instructions!PUSH}
呼び出しの前に、\PUSH 命令によって \TT{hello, world} 文字列のアドレス（またはその文字列へのポインタ）がスタックに置かれる。

\printf 関数から \main 関数へ制御が返されたとき、文字列アドレス（またはそのポインタ）はまだスタック上にある。これはもはや不必要なので、スタックポインタ（ \ESP レジスタ）を修正しなければいけない。

\myindex{x86!\Instructions!ADD}
\INS{ADD ESP, 4}は \ESP レジスタ値に4を加算することを意味します。

なぜ4なのでしょう？これは32ビットプログラムなので、スタックポインタに4バイト（x64コードの場合は8バイト）加算することで，文字列へのアドレスのサイズ分だけスタックポインタを移動させたことを意味している。
\INS{ADD ESP, 4} は \INS{POP register} とほぼ同等だが、 \INS{POP register} と異なりレジスタを使用しない命令となっている\footnote{しかしながら，CPUフラグレジスタは変更される．}．

\myindex{Intel C++}
\myindex{\oracle}
\myindex{x86!\Instructions!POP}

インテルC++コンパイラなどでは、同様の目的のために\ADD の代わりに\TT{POP ECX}を発行するものもある
（例えば、\oracle{} のコードで見ることができる）。この命令は \ADD とほぼ同じ効果を持つが、\ECX レジスタの内容は上書きされる。インテルC++コンパイラは、この命令コードが\TT{ADD ESP, x}（\TT{POP}の場合は1バイト、\TT{ADD}の場合は3バイト）よりも短いために、\TT{POP ECX}を使用するようである。

\oracle{} のコードにおいて \ADD の代わりに \POP を使用する例を次に示す。

\begin{lstlisting}[caption=\oracle 10.2 Linux (app.o file),style=customasmx86]
.text:0800029A                 push    ebx
.text:0800029B                 call    qksfroChild
.text:080002A0                 pop     ecx
\end{lstlisting}

%Read more about the stack in section
% ~(\myref{sec:stack}).
\myindex{\CLanguageElements!return}
\printf 関数を呼び出した後、元の \CCpp コードには、\main 関数の返り値として\TT{return 0}というステートメントが含まれています。

\myindex{x86!\Instructions!XOR}
このコードでは，\INS{XOR EAX, EAX}命令によって実装されている。

\myindex{x86!\Instructions!MOV}

\XOR は \q{eXclusive OR}\footnote{\href{http://go.yurichev.com/17118}{Wikipedia}} だが、\INS{MOV EAX, 0} の代用として使用されることもある。 \MOV よりも若干短い命令コード（ \MOV の場合は5に対して \XOR の場合は2バイト）であるためでだ。

\myindex{x86!\Instructions!SUB}
一部のコンパイラは\INS{SUB EAX, EAX}を出力する。これは、 \EAX の値を \EAX \IT{の値から} \IT{差し引くこと（SUBtract）}を意味する。つまり，\EAX の値はゼロとなります。

\myindex{x86!\Instructions!RET}
最後に書かれたの命令 \RET は、\gls{caller}に制御を返す。 通常、これは \CCpp \ac{CRT}コードであり、これは\ac{OS}に制御を戻すことを意味する。
